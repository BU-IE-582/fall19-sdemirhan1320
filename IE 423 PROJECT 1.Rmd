---
title: "IE 423 Project 1"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


##PROJECT PART 1
###Question 1-)
Read image as a variable in R/Python. For R, you need to install "jpeg" package to read image into avariable. The variable you obtain is an array with three dimensions (suppose you read image to a variable "img", try running "str(img)" command to see the structure of the variable. The size of the array should be 512 x 512 x 3 for the three dimensions). If you prefer Python, please find the appropriate module for this task.
```{r}
library(jpeg)
getwd()
setwd("C:/Users/Sinan/Desktop")
img<-readJPEG("surfacenew.jpg")
str(img)

```
###Question 2-)
What is the structure of the variable that stores the image? What is the dimension? 
```{r}
dim(img)
```

The structure of the variable that stores the image is large array

a. Display the image.
```{r}
#a-)
plot(1:2, type='n')
rasterImage(img, 1, 1, 2, 2)

```


b. Display each channel using "image" function on a single plot.
```{r}
R_channel<-matrix(img[ , , 1], 512, 512)
G_channel<-matrix(img[ , , 2], 512, 512)
B_channel<-matrix(img[ , , 3], 512, 512)

par(mfrow = c(1,3))
image(R_channel)
image(G_channel)
image(B_channel)
```

###Question 3-)
For each channel, take the average of the columns and plot the average as a line plot for each channel on a single plot.
```{r}
avr_red<-(colSums(R_channel))/512
avr_green<-(colSums(G_channel))/512
avr_blue<-(colSums(B_channel))/512
```



```{r}
plot(avr_red, type="l", col="red",ylim = range(0.35,0.67))
lines(avr_green, col="green")
lines(avr_blue, col="blue")

```

###Question 4-)
For each channel, subtract one half of the image from the other half (choice of halves is up to you but cropping the image vertically/horizontally into two parts make more sense) and display the new image.
```{r}
halfred<-R_channel[ ,1:256] 
half2red<-R_channel[ ,512:257]
image(halfred)
image(half2red)
red_new<-abs(halfred-half2red)
```


```{r}
halfgreen<-G_channel[ ,1:256] 
half2green<-G_channel[ ,512:257]
image(halfgreen)
image(half2green)
green_new<-abs(halfgreen-half2green)
```


```{r}
halfblue<-B_channel[ ,1:256] 
half2blue<-B_channel[ ,512:257]
image(halfblue)
image(half2blue)
blue_new<-abs(halfblue-half2blue)
```



```{r}

```



```{r}
newimg<-img[1:512,257:512,1:3]
newimg<-red_new
newimg<-green_new
newimg<-blue_new
plot(1:2, type='n')
rasterImage(newimg, 1, 1, 2, 2)


```




###Question 5-)
Apply median filtering to each channel of the image with the following window sizes, display the
images (as a color image like in part 2-a) and discuss about the effect of window size based on your observations: 
a) 5x5
```{r}
library("EBImage")

median_5<-medianFilter(img,5)
plot(1:2, type='n')
rasterImage(median_5, 1, 1, 2, 2)
```

b) 11x11
```{r}
median_11<-medianFilter(img,11)
plot(1:2, type='n')
rasterImage(median_11, 1, 1, 2, 2)
```

c) 31x31
```{r}
median_31<-medianFilter(img,31)

plot(1:2, type='n')
rasterImage(median_31, 1, 1, 2, 2)

```


##PROJECT PART 2

Before working on the tasks, please transform your color image to a greyscale one using an image editor. The other option is to use some package/module to perform the transformation. You will be working on greyscale images for the following tasks:
```{r}
require(stats)
library("imager")
library(ggplot2)
library(dplyr)
library("EBImage")
im <- load.image('surfacenew.jpg')
plot(im)

img_g<-grayscale(im)
plot(img_g)

```




###Question 1-)
Suppose we are interested in the pixel value distribution of our image. Draw the histogram of the pixel values. Provide an appropriate probability distribution that fits well to the shape you observe 
```{r}
pixel_for_dim<- as.data.frame(img_g)
pixels<-pixel_for_dim[,3]
hist(pixels) #Normal Distribution

```

We can see that pixel values are distributed with normal distribution.

###Question 2-)
Assume that pixel values are following the distribution you have proposed in the previous task.
Estimate the parameters using the data.

```{r}
#mean median variance and mode values
mean(pixels)  #0.5687696
```

```{r}
median(pixels)
```

```{r}
var(pixels)
```

```{r}
sqrt(var(pixels))
```

```{r}
getmode <- function(v) {
  uniqv <- unique(v)
  uniqv[which.max(tabulate(match(v, uniqv)))]
}
getmode(pixels)
```

###Question 3-)
Let's say the pixel values follow the distribution you proposed and its parameters are equal to what you have estimated in part 2. Identify the pixels that are out of the 0.001 probability limits. In other words, find a lower and upper bound that leave 0.001 of the observations on the smaller and large side of the distribution respectively. Pixels that are out of these bounds should be identified. After finding those pixels, change the value of these pixels to zero (i.e. black color). Display the new image and original image in a plot. What are your observations? Comment on your findings.

```{r}
sum1<-0
sum2<-0
#262144*0.001 =263

quantile(pixels, 0.001) #0.2873333
quantile(pixels, 0.999) #0.8824314
```

By using for loops,We can see how many pixels those are out of the lower and upper bounds
```{r}
new_pixels<-pixel_for_dim
for (i in c(1:262144)){
  if (new_pixels[,3][i]<=0.2873333){
    sum1<-sum1+1
  }
} 
sum1 #262
```

```{r}
for (i in c(1:262144)){
  if (new_pixels[,3][i]>=0.8824314){
    sum2<-sum2+1
  }
}
sum2 #258
```

Pixels that are out of these bounds are identified and after
finding those pixels,we changed the value of these pixels to zero.
```{r}
for (i in c(1:262144)){
  if (new_pixels[,3][i]>=0.8824314){
    new_pixels[,3][i]=0
  }
  else if (new_pixels[,3][i]<=0.2873333){
    new_pixels[,3][i]=0
  }
}
```
Display the new image and original image in a plot.

```{r}
#total
blacked_pixels<-new_pixels[,3] %>% as.cimg(dim=dim(img_g))

par(mfrow = c(1,2))
plot(1:2, type='n')
rasterImage(img_g, 1, 1, 2, 2)
plot(1:2, type='n')
rasterImage(blacked_pixels, 1, 1, 2, 2)
a=c(1,2)

```

###Question 4-)
Suppose we would like to perform the same operation on the patches of images (i.e. windows of
certain size). When local structures are important, performing image operations on the patches might be important. Assume that your window size is 51x51 and you repeated what you have done in the first three tasks. Note that you do not need to draw each patch as requested in the previous task (i.e. task 3) but you are expected to mark the pixels for every patch. After finding those pixels, change the value of these pixels to zero (i.e. black color). Display the new image and original image in a plot. What are your observations? Comment on your findings

```{r}
new_windows<-img_g
hist_data_of_windows<-array(0,dim = c(10,10,2601))
mean_of_windows<-array(0,dim = c(10,10))
variance_of_windows<-array(0,dim = c(10,10))
sum_of_blacked<-0
```

By using for loop,We found those pixels which are out of the lower and the upper bounds and changed the value of those pixels to zero
```{r}

for (k in c(1:10)){
  for(l in c(1:10)){
    kleft<-(1+(51*k)-51)
    kright<-(51*k)
    lleft<-(1+(51*l)-51)
    lright<-(51*l)
    image_new<-new_windows[kleft:kright,lleft:lright]
    low<-quantile(image_new, 0.001)
    high<-quantile(image_new, 0.999)
    
    for(i in c(1:2601)){
      if(image_new[i]<= low){
        image_new[i]=0
        sum_of_blacked=sum_of_blacked+1
      }
      else if(image_new[i]>=high){
        image_new[i]=0
        sum_of_blacked=sum_of_blacked+1
      }
      
    }
    mean_of_windows[k,l]=mean(image_new)
    variance_of_windows[k,l]=var(as.data.frame(as.cimg(image_new))[,3])
    hist_data_of_windows[k,l,]=image_new
    
    new_windows[kleft:kright,lleft:lright]=image_new
  }
}

```

We can see the statical parameters for each patches.
```{r}
mean_of_windows
```

```{r}
variance_of_windows
```

```{r}
sum_of_blacked  #624
```



To see the histograms of each 100 patches.
```{r}
for(i in c(1:10)){
  par(mfrow= c(2,5))
  for (j in c(1:10)) {
    hist(hist_data_of_windows[i,j,])
  }
  
}
```


Displaying the new image and original image in a plot
```{r}
par(mfrow = c(1,2))
plot(1:2, type='n')
rasterImage(img_g, 1, 1, 2, 2)
plot(1:2, type='n')
rasterImage(new_windows, 1, 1, 2, 2)
```





